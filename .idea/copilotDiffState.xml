<?xml version="1.0" encoding="UTF-8"?>
<project version="4">
  <component name="CopilotDiffPersistence">
    <option name="pendingDiffs">
      <map>
        <entry key="$PROJECT_DIR$/code1/Makefile">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/code1/Makefile" />
              <option name="originalContent" value="# Makefile for Windows using nmake and fl32&#10;&#10;.SUFFIXES: .for .obj .exe&#10;&#10;FORTRAN = fl32&#10;FFLAGS = -c&#10;&#10;OBJS = mo1.obj&#10;EXE = Code1.exe&#10;&#10;all: $(EXE)&#10;&#10;$(EXE): Code1.for $(OBJS) naglib.lib&#10;&#9;$(FORTRAN) Code1.for $(OBJS) naglib.lib&#10;&#10;mo1: mo1.obj&#10;&#10;mo1.obj: mo1.for&#10;&#9;$(FORTRAN) $(FFLAGS) mo1.for&#10;&#10;AlMg:&#10;&#9;cp mo1AlMg.for mo1.for&#10;&#9;$(MAKE)&#10;&#10;KrMg:&#10;&#9;cp mo1KrMg.for mo1.for&#10;&#9;$(MAKE)&#10;&#10;KrHe:&#10;&#9;cp mo1KrHe.for mo1.for&#10;&#9;$(MAKE)&#10;&#10;clean:&#10;&#9;rm *.exe *.obj *.mod&#10;" />
              <option name="updatedContent" value="# Makefile for Windows using nmake and fl32&#10;&#10;.SUFFIXES: .for .obj .exe&#10;&#10;FORTRAN = fl32&#10;FFLAGS = -c&#10;&#10;# Additional source files to be compiled and linked with the main program&#10;# To add more source files to the program:&#10;# 1. Add the .f filename to the ADDITIONAL_SOURCES list below (space-separated)&#10;# 2. Add the corresponding .obj filename to the ADDITIONAL_OBJS list&#10;# 3. The object files will be automatically compiled and linked&#10;ADDITIONAL_SOURCES = emiabso.f eff.f open_read.f linelist.f&#10;ADDITIONAL_OBJS = emiabso.obj eff.obj open_read.obj linelist.obj&#10;&#10;# Original object files&#10;OBJS = mo1.obj $(ADDITIONAL_OBJS)&#10;EXE = Code1.exe&#10;&#10;all: $(EXE)&#10;&#10;# Link all object files together to create the executable&#10;$(EXE): Code1.for $(OBJS) naglib.lib&#10;&#9;$(FORTRAN) Code1.for $(OBJS) naglib.lib&#10;&#10;mo1: mo1.obj&#10;&#10;mo1.obj: mo1.for&#10;&#9;$(FORTRAN) $(FFLAGS) mo1.for&#10;&#10;# Pattern rule to compile .f files to .obj files&#10;# This automatically handles compilation of additional source files&#10;%.obj: %.f&#10;&#9;$(FORTRAN) $(FFLAGS) $&lt;&#10;&#10;AlMg:&#10;&#9;cp mo1AlMg.for mo1.for&#10;&#9;$(MAKE)&#10;&#10;KrMg:&#10;&#9;cp mo1KrMg.for mo1.for&#10;&#9;$(MAKE)&#10;&#10;KrHe:&#10;&#9;cp mo1KrHe.for mo1.for&#10;&#9;$(MAKE)&#10;&#10;clean:&#10;&#9;rm *.exe *.obj *.mod" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/code1/Makefile.dqags">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/code1/Makefile.dqags" />
              <option name="originalContent" value="# Makefile for Netlib-only version&#10;&#10;FORTRAN = fl32&#10;FFLAGS = -c&#10;&#10;PROGRAM = dqags_test.exe&#10;SOURCE = dqags_test.for&#10;&#10;# Try with minimal netlib libraries&#10;LIBS = libslatec.lib libodepack.lib libquadpack.lib&#10;&#10;all: $(PROGRAM)&#10;&#10;$(PROGRAM): $(SOURCE)&#10;&#9;$(FORTRAN) $(SOURCE) $(LIBS) /Fe$(PROGRAM)&#10;&#10;clean:&#10;&#9;@if exist dqags_test.obj del dqags_test.obj&#10;&#9;@if exist $(PROGRAM) del $(PROGRAM)&#10;" />
              <option name="updatedContent" value="# Makefile for Netlib-only version&#10;&#10;FORTRAN = fl32&#10;FFLAGS = -c&#10;&#10;PROGRAM = dqags_test.exe&#10;&#10;# Main source file&#10;MAIN_SOURCE = dqags_test.for&#10;&#10;# Additional source files to be compiled and linked&#10;# To add more source files to the program:&#10;# 1. Add the .f filename to the SOURCES list below (space-separated)&#10;# 2. The corresponding .obj file will be automatically generated&#10;# 3. All object files will be linked together with the main program&#10;SOURCES = emiabso.f eff.f open_read.f linelist.f&#10;&#10;# Generate object file names from source files&#10;OBJECTS = $(SOURCES:.f=.obj)&#10;MAIN_OBJECT = $(MAIN_SOURCE:.for=.obj)&#10;&#10;# Try with minimal netlib libraries&#10;LIBS = libslatec.lib libodepack.lib libquadpack.lib&#10;&#10;all: $(PROGRAM)&#10;&#10;# Link all object files together to create the executable&#10;$(PROGRAM): $(MAIN_OBJECT) $(OBJECTS)&#10;&#9;$(FORTRAN) $(MAIN_OBJECT) $(OBJECTS) $(LIBS) /Fe$(PROGRAM)&#10;&#10;# Compile main source file to object&#10;$(MAIN_OBJECT): $(MAIN_SOURCE)&#10;&#9;$(FORTRAN) $(FFLAGS) $(MAIN_SOURCE)&#10;&#10;# Pattern rule to compile .f files to .obj files&#10;%.obj: %.f&#10;&#9;$(FORTRAN) $(FFLAGS) $&lt;&#10;&#10;clean:&#10;&#9;@if exist $(MAIN_OBJECT) del $(MAIN_OBJECT)&#10;&#9;@if exist $(PROGRAM) del $(PROGRAM)&#10;# Clean up all generated object files&#10;# To add cleanup for new source files: they will be automatically&#10;# included if you add them to the SOURCES variable above&#10;&#9;@for %%f in ($(OBJECTS)) do @if exist %%f del %%f" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/code1/dqags_nag_test.for">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/code1/dqags_nag_test.for" />
              <option name="originalContent" value="      program dqags_nag_test&#10;      implicit none&#10;&#10;c     Test program for DQAGS (Netlib/QUADPACK) and D01AHF (NAG)&#10;c     Compatible with Microsoft Fortran PowerStation 4.0&#10;&#10;c     External function to be integrated&#10;      external func_for_int&#10;&#10;c     DQAGS variables&#10;      double precision a, b, epsabs, epsrel, result, abserr&#10;      integer limit, neval, ier, last&#10;      integer lenw&#10;      parameter (lenw = 400)&#10;      integer iwork(lenw)&#10;      double precision work(lenw)&#10;&#10;c     NAG D01AHF variables&#10;      double precision nag_a, nag_b, nag_epsabs, nag_epsrel&#10;      double precision nag_result, nag_abserr&#10;      integer nag_limit&#10;      integer nag_leniw, nag_lenw&#10;      parameter (nag_leniw = 200)&#10;      parameter (nag_lenw = 200)&#10;      integer nag_iw(nag_leniw)&#10;      double precision nag_w(nag_lenw)&#10;      integer nag_ifail&#10;&#10;c     Common variables&#10;      double precision analytical_sol&#10;&#10;      write(*,*) '=========================================='&#10;      write(*,*) 'DQAGS (Netlib) and D01AHF (NAG) Test'&#10;      write(*,*) '=========================================='&#10;      write(*,*)&#10;      write(*,*) 'Integrating f(x) = x*x from 0 to 1'&#10;      write(*,*) 'Analytical solution = 1/3'&#10;      analytical_sol = 1.0d0 / 3.0d0&#10;      write(*,*) 'Analytical solution:', analytical_sol&#10;      write(*,*)&#10;&#10;c     ---------------------------------&#10;c     Test 1: DQAGS from Netlib/QUADPACK&#10;c     ---------------------------------&#10;      write(*,*) '--- Testing DQAGS (Netlib/QUADPACK) ---'&#10;      a = 0.0d0&#10;      b = 1.0d0&#10;      epsabs = 1.0d-10&#10;      epsrel = 1.0d-10&#10;      limit = 100&#10;&#10;      call DQAGS(func_for_int, a, b, epsabs, epsrel, result,&#10;     +           abserr, neval, ier, limit, lenw, last, iwork, work)&#10;&#10;      write(*,*) 'DQAGS Results:'&#10;      write(*,*) '  Result:', result&#10;      write(*,*) '  Absolute error estimate:', abserr&#10;      write(*,*) '  Number of evaluations:', neval&#10;      write(*,*) '  Exit code (ier):', ier&#10;      write(*,*) '  Actual absolute error:', abs(result - analytical_sol)&#10;      write(*,*)&#10;&#10;c     ---------------------------------&#10;c     Test 2: D01AHF from NAG Library&#10;c     ---------------------------------&#10;      write(*,*) '--- Testing D01AHF (NAG) ---'&#10;      nag_a = 0.0d0&#10;      nag_b = 1.0d0&#10;      nag_epsabs = 1.0d-10&#10;      nag_epsrel = 1.0d-10&#10;      nag_limit = 100&#10;      nag_ifail = 0&#10;&#10;      call D01AHF(nag_a, nag_b, func_for_int, nag_epsabs, nag_epsrel,&#10;     +            nag_limit, nag_result, nag_abserr, nag_w, nag_lenw,&#10;     +            nag_iw, nag_leniw, nag_ifail)&#10;&#10;      write(*,*) 'D01AHF Results:'&#10;      write(*,*) '  Result:', nag_result&#10;      write(*,*) '  Absolute error estimate:', nag_abserr&#10;      write(*,*) '  Exit code (ifail):', nag_ifail&#10;      write(*,*) '  Actual absolute error:', abs(nag_result - analytical_sol)&#10;      write(*,*)&#10;&#10;      write(*,*) '=========================================='&#10;      write(*,*) 'Test Complete'&#10;      write(*,*) '=========================================='&#10;&#10;      end&#10;&#10;c     ========================================&#10;c     Function to be integrated: f(x) = x*x&#10;c     ========================================&#10;      double precision function func_for_int(x)&#10;      implicit none&#10;      double precision x&#10;      func_for_int = x * x&#10;      return&#10;      end&#10;&#10;" />
              <option name="updatedContent" value="program dqags_test&#13;&#10;      implicit none&#13;&#10;&#13;&#10;c     Test program for DQAGS (Netlib/QUADPACK)&#13;&#10;c     Compatible with Microsoft Fortran PowerStation 4.0&#13;&#10;&#13;&#10;c     External function to be integrated&#13;&#10;      external func_for_int&#13;&#10;&#13;&#10;c     DQAGS variables&#13;&#10;      double precision a, b, epsabs, epsrel, result, abserr&#13;&#10;      integer limit, neval, ier, last&#13;&#10;      integer lenw&#13;&#10;      parameter (lenw = 400)&#13;&#10;      integer iwork(lenw)&#13;&#10;      double precision work(lenw)&#13;&#10;&#13;&#10;c     Common variables&#13;&#10;      double precision analytical_sol&#13;&#10;&#13;&#10;      write(*,*) '=========================================='&#13;&#10;      write(*,*) 'DQAGS (Netlib/QUADPACK) Test'&#13;&#10;      write(*,*) '=========================================='&#13;&#10;      write(*,*)&#13;&#10;      write(*,*) 'Integrating f(x) = x*x from 0 to 1'&#13;&#10;      write(*,*) 'Analytical solution = 1/3'&#13;&#10;      analytical_sol = 1.0d0 / 3.0d0&#13;&#10;      write(*,*) 'Analytical solution:', analytical_sol&#13;&#10;      write(*,*)&#13;&#10;c&#13;&#10;c     ---------------------------------&#13;&#10;c     Test 1: DQAGS from Netlib/QUADPACK&#13;&#10;c     ---------------------------------&#13;&#10;      write(*,*) '--- Testing DQAGS (Netlib/QUADPACK) ---'&#13;&#10;      a = 0.0d0&#13;&#10;      b = 1.0d0&#13;&#10;      epsabs = 1.0d-10&#13;&#10;      epsrel = 1.0d-10&#13;&#10;      limit = 100&#13;&#10;&#13;&#10;      call DQAGS(func_for_int, a, b, epsabs, epsrel, result,&#13;&#10;     +           abserr, neval, ier, limit, lenw, last, iwork, work)&#13;&#10;&#13;&#10;      write(*,*) 'DQAGS Results:'&#13;&#10;      write(*,*) '  Result:', result&#13;&#10;      write(*,*) '  Absolute error estimate:', abserr&#13;&#10;      write(*,*) '  Number of evaluations:', neval&#13;&#10;      write(*,*) '  Exit code (ier):', ier&#13;&#10;      write(*,*) '  Actual absolute error:', dabs(result -&#13;&#10;     +           analytical_sol)&#13;&#10;      write(*,*)&#13;&#10;c&#13;&#10;      write(*,*) '=========================================='&#13;&#10;      write(*,*) 'Test Complete'&#13;&#10;      write(*,*) '=========================================='&#13;&#10;&#13;&#10;      end&#13;&#10;&#13;&#10;c     ========================================&#13;&#10;c     Function to be integrated: f(x) = x*x&#13;&#10;c     ========================================&#13;&#10;      double precision function func_for_int(x)&#13;&#10;      implicit none&#13;&#10;      double precision x&#13;&#10;      func_for_int = x * x&#13;&#10;      return&#13;&#10;      end" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/code1/globals.inc">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/code1/globals.inc" />
              <option name="originalContent" value="C      globals.inc - Shared parameters and variables for the plasma code&#10;C&#10;C      --- Parameters ---&#10;       INTEGER, PARAMETER :: NSTm=300, nvM=3000, LaMx=2, mSpe=6&#10;       REAL(8), PARAMETER :: pin=3.1415926535d0, one=1.d0, zero=0.d0&#10;C&#10;C      --- Plasma State Common Block ---&#10;       COMMON /STATE/ La, tf, ti, Te, TiD, DenI, Dene, R2, ZC1, ZC2&#10;       INTEGER La, ng&#10;       REAL(8) tf, ti, Te, TiD, DenI(2), Dene, R2, ZC1, ZC2, POPt(NSTm, 2, LaMx)&#10;C&#10;C      --- Atomic and Line Data Common Block ---&#10;       COMMON /LINES/ hvC(MNLe), nLo(MNLe), nUp(MNLe), nX3(MNLe), linM4&#10;       INTEGER nLo, nUp, nX3, linM4&#10;       REAL(8) hvC, A(NSTm,NSTm,2), g0(NSTm,2), E(NSTm,2), flu(NSTm,NSTm,2)&#10;C&#10;C      --- Output Arrays Common Block ---&#10;       COMMON /OUTPUT/ emTot(LaMx,nvM), abTot(LaMx,nvM)&#10;       REAL(8) emTot, abTot&#10;C&#10;C      (add all other necessary common blocks and variables here)" />
              <option name="updatedContent" value="C      globals.inc - Shared parameters and variables for the plasma code&#10;C&#10;C      --- Parameters ---&#10;       INTEGER, PARAMETER :: NSTm=1612, nvM=12300, LaMx=2, mSpe=6&#10;       INTEGER, PARAMETER :: MNLe=11566, nXE=2, HSSm=36&#10;       REAL(8), PARAMETER :: pin=3.1415926535d0, one=1.d0, zero=0.d0&#10;       REAL(8), PARAMETER :: ToPi=2.d0*pin, FoPi=4.d0*pin&#10;       REAL(8), PARAMETER :: BolJ=1.6021773d-19, h=4.1356692d-15&#10;       REAL(8), PARAMETER :: eVA=12398.424d0&#10;C&#10;C      --- Plasma State Common Block ---&#10;       COMMON /STATE/ La, tf, ti, Te, TiD, DenI, Dene, R2, ZC1, ZC2, ng&#10;       INTEGER La, ng&#10;       REAL(8) tf, ti, Te, TiD, DenI(2), Dene, R2, ZC1, ZC2&#10;C&#10;C      --- Population and Energy Level Data ---&#10;       COMMON /LEVELS/ POPt, E, g0, BE, A, flu, Wout&#10;       REAL(8) POPt(NSTm, nXE, LaMx), E(NSTm,nXE), g0(NSTm,nXE)&#10;       REAL(8) BE(NSTm), A(NSTm,NSTm,nXE), flu(NSTm,NSTm,nXE)&#10;       REAL(8) Wout(NSTm,nXE,LaMx)&#10;C&#10;C      --- Atomic and Line Data Common Block ---&#10;       COMMON /LINES/ hvC, nLo, nUp, nX3, linM4, hvV&#10;       INTEGER nLo(MNLe), nUp(MNLe), nX3(MNLe), linM4&#10;       REAL(8) hvC(MNLe), hvV(nvM)&#10;C&#10;C      --- Ion and Species Data ---&#10;       COMMON /SPECIES/ Den, Nnu, FSS, HSS, NST, kiSS, nprin&#10;       INTEGER Nnu(nXE), FSS(nXE), HSS(nXE), NST(nXE)&#10;       INTEGER kiSS(NSTm,nXE), nprin(NSTm,nXE)&#10;       REAL(8) Den(nXE)&#10;C&#10;C      --- Spectral Data ---&#10;       COMMON /SPECTRAL/ FWkVcGAU, AtMass, PI, PIR, DPI, hvSmo, hvMax&#10;       REAL(8) FWkVcGAU(nXE), AtMass(nXE), PI(HSSm,nXE)&#10;       REAL(8) PIR(HSSm,nXE), DPI(HSSm,nXE), hvSmo, hvMax&#10;C&#10;C      --- Output Arrays Common Block ---&#10;       COMMON /OUTPUT/ emTot, abTot, FWevLor, FWvoi&#10;       REAL(8) emTot(LaMx,nvM), abTot(LaMx,nvM)&#10;       REAL(8) FWevLor(MNLe), FWvoi(MNLe)&#10;C&#10;C      --- Names and Control ---&#10;       COMMON /NAMES/ QSname1, QSname2, gpEq, PrFr&#10;       CHARACTER*5 QSname1(NSTm,nXE), QSname2(NSTm,nXE)&#10;       INTEGER gpEq(mSpe), PrFr" />
            </PendingDiffInfo>
          </value>
        </entry>
      </map>
    </option>
  </component>
</project>